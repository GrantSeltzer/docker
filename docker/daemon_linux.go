// +build daemon

package main

import (
	"os"
	"strings"

	"github.com/Sirupsen/logrus"
	systemdDaemon "github.com/coreos/go-systemd/daemon"
	"github.com/coreos/go-systemd/journal"
	"github.com/docker/docker/daemon"
	"github.com/docker/docker/pkg/jsonlog"
)

// notifySystem sends a message to the host when the server is ready to be used
func notifySystem() {
	// Tell the init daemon we are accepting requests
	go systemdDaemon.SdNotify("READY=1")
}

// configureLogging sets us up to log messages generated by the daemon itself
func configureLogging(config *daemon.Config) {
	if os.Getenv("NOTIFY_SOCKET") == "" {
		// no notify socket -> not running under systemd, use defaults
		logrus.SetFormatter(&logrus.TextFormatter{
			TimestampFormat: jsonlog.RFC3339NanoFixed,
			DisableColors:   config.RawLogs,
		})
	} else {
		// skip redundant timestamps and log directly to the journal
		logrus.SetFormatter(&logrus.TextFormatter{
			DisableTimestamp: true,
			DisableColors:    config.RawLogs,
		})
		logrus.SetOutput(newJournalWriter(nil))
	}
}

type journalWriter struct {
	vars map[string]string
}

// newJournalWriter creates and returns a new journal writer.
func newJournalWriter(vars map[string]string) (j *journalWriter) {
	return &journalWriter{vars: vars}
}

// Parse the text that we're logging to dig out the message priority, then send
// it directly to the journal.
func (j *journalWriter) Write(data []byte) (n int, err error) {
	// Find the log message level and convert that to a journal priority
	priority := journal.PriDebug
	s := string(data)
	if i := strings.Index(s, "level="); i > 0 {
		switch strings.ToLower(s[i+6 : i+10]) {
		case "debu":
			priority = journal.PriDebug
			break
		case "info":
			priority = journal.PriInfo
			break
		case "warn":
			priority = journal.PriWarning
			break
		case "erro":
			priority = journal.PriErr
			break
		case "fata":
			priority = journal.PriAlert
			break
		case "pani":
			priority = journal.PriEmerg
			break
		}
	}
	// Send it directly to the journal
	err = journal.Send(s, priority, j.vars)
	if err != nil {
		return 0, err
	}
	return len(data), nil
}
